---
layout:     post
title:    关于SPI Flash的那些事儿
subtitle:	硬件知识
date:       2020-06-25 15:00:00 +0800
author:     Wang Chao
header-img: img/bg4.jpg
catalog:    true
tag:
    - 硬件
---


以华邦W25Q128为例，详解SPI Flash的特点，读写注意事项，和地址范围等。

### 和EPROM的区别

以AT24C02 EPROM和W25Q128 SPI Flash为例。

- EPROM通常采用是IIC串行总线，低速，单双工，通信速率一般是百KHz。而SPI Flash是采用的SPI总线，高速，全双工，通讯速率一般是百MHz。SPI Flash属于Flash ROM闪存，相比于EPROM，读写速度更快。
- EPROM通常用于存储不频繁读取的数据，如配置信息等，而EPROM通常用来存储经常读取的数据，如字库文件等。
- EPROM读写比较随意，想写那个地址写那个，想读哪个地址读哪个！而SPI Flash则比较规范，**擦除的最小单位是扇区**。向某个地址写入数据时， 要先读取这个地址的数据是否为0xFF，如果不是0xFF，那么这个数据**写入失败**。所以通常的写操作是，在写某个地址之前，**直接擦除这个地址所在的那个扇区**，然后再写数据。当然，如果这个扇区的所有内容都是0xFF，则无需擦除，可以直接写入。
- EPROM通常容量比较小，大小为KB级的，如AT24C02是2KB，而SPI Flash容量比较大，大小为MB级的，如W25Q16是16Mbit，也就是2MB。
- EPROM型号通常是**xx24系列**，而SPI Flash通常是**xx25系列**，所以从芯片型号我们也可以看出ROM类型。
- EPROM数据保存时间大约是100年，而SPI Flash数据保存时间为20年。
- EPROM的读写次数为100万次左右，SPI Flash读写次数为10万次左右


AT24C02读写次数和存储时间

![AT24C02读写次数和存储时间](https://img-blog.csdnimg.cn/20200625131811431.png)

W25Q128读写次数和存储时间

![W25Q128读写次数和存储时间](https://img-blog.csdnimg.cn/20200625131746686.png)

### 块、扇区、页傻傻分不清

以华邦的W25Q128为例，容量为128Mbits，注意这里的单位是bit，换算成字节(Byte)，也就是：`128Mbits/8 = 16MB = 16*1024KB = 16384 KB = 16,777,216B`，所以很容易计算出整个存储空间的地址范围：`0x000000~0xFFFFFF`

SPI Flash和EPROM的很大的一个不同就是多了块、扇区、页的概念。

W25Q128的整个存储空间被分成了256个块（Block），每个块包含16个扇区（Sector），每个扇区又包括16个页。

所以，如果按照块来计算，W25Q128包括`256`个块。
如果按照扇区来计算，W25Q128包括`256*16=4096`个扇区。
如果按照页来计算的话，W25Q128包括`4096*16=65536`个页。

每个块的大小是：`16384KB/256 = 64KB`
每个扇区的大小是：`64KB/16 = 4KB`
每个页的大小是：`4KB/16 = 256B`

但是实际上，我们在进行读写操作时，都是区分块和扇区，不区分页的。包括在官方的Datasheet中，并没有重点提及页的地址范围。

![地址范围](https://img-blog.csdnimg.cn/20200625133451926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doaWsxMTk0,size_16,color_FFFFFF,t_70)

### 地址范围

从存储容量来看，我们可以轻松的计算出W25Q128的整个存储空间的地址范围：`0x000000~0xFFFFFF`，也就是地址最大是24位。根据块的大小是64KB，扇区的大小是4KB，我们可以计算出每个块和扇区的地址范围：

```

块0的地址：`0x000000~0x00FFFF`
块1的地址：`0x010000~0x01FFFF`
.....
块255的地址：`0xFF0000~0xFFFFFF`

```

对于每个块，以块0为例：

```

块0扇区0的地址：`0x000000~0x000FFF`
块0扇区1的地址：`0x001000~0x001FFF`
....
块0扇区15的地址：`0x00F000~0x00FFF`

```

不知道你是否发现了，地址的高8位(23-16位)表示块的位置，第15-12位为扇区的位置。

例如，块10的第7个扇区的地址范围：`0x0A 7 000 ~ 0x0A 7 FFF`；

W25Q128支持读取任意一个地址的数据，范围：`0x000000~0xFFFFFF`

根据绝对地址，获取这个地址所在的块和扇区位置就很简单了：

```c

/* 存储地址 */
uint32_t addr = 0xC0A002;

/* 23-16位是块的位置 */
uint8_t block = addr >> 16;	/* (addr & 0xFF0000)>>16*/

/* 15-12位是扇区的位置 */
uint8_t sector = (addr << 16) >> 28; /* (addr & 0x00F000)>>12 */
uart_init(115200);

printf("addr:%x, block:%d, sector:%d\r\n", addr, block, sector);

```

运行结果

![运行结果](https://img-blog.csdnimg.cn/20200625141559379.png)

### 常用指令

W25Q128的擦除，可以通过指令配置为单独的扇区擦除，单独的块擦除，或者整片擦除，整片擦除时间会比较长。

```c

0xC7：整片擦除
0xD8：块擦除
0x20：扇区擦除
0xAB：获取芯片ID
0x90：获取芯片型号
0x06：写使能
0x04：禁止写
0xB9：进入掉电模式，功耗极低
0xAB：退出掉电模式

```

发送0x90命令之后的返回值表示当前器件的型号：

```c

/*
0XEF13,表示芯片型号为W25Q80
0XEF14,表示芯片型号为W25Q16
0XEF15,表示芯片型号为W25Q32
0XEF16,表示芯片型号为W25Q64
0XEF17,表示芯片型号为W25Q128
*/

```

